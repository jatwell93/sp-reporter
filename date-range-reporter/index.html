<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Date Range Reporter</title>

    <style>
      :root {
        /* Light theme colors (default) */
        --bg-primary: #f5f5f5;
        --bg-secondary: #ffffff;
        --bg-tertiary: #f9f9f9;
        --bg-code: #fafafa;
        --text-primary: #333333;
        --text-secondary: #666666;
        --text-tertiary: #999999;
        --border-color: #e0e0e0;
        --border-light: #ddd;
        --accent-color: #1976d2;
        --accent-hover: #1565c0;
        --accent-active: #0d47a1;
        --shadow: rgba(0, 0, 0, 0.1);
        --shadow-strong: rgba(0, 0, 0, 0.2);
      }

      body.dark-theme {
        /* Dark theme colors */
        --bg-primary: #1e1e1e;
        --bg-secondary: #2d2d2d;
        --bg-tertiary: #383838;
        --bg-code: #252525;
        --text-primary: #e0e0e0;
        --text-secondary: #b0b0b0;
        --text-tertiary: #808080;
        --border-color: #404040;
        --border-light: #505050;
        --accent-color: #42a5f5;
        --accent-hover: #64b5f6;
        --accent-active: #90caf9;
        --shadow: rgba(0, 0, 0, 0.3);
        --shadow-strong: rgba(0, 0, 0, 0.5);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        padding: 20px;
        background: var(--bg-primary);
        color: var(--text-primary);
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 24px;
        box-shadow: 0 2px 8px var(--shadow);
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }

      h1 {
        font-size: 24px;
        margin-bottom: 24px;
        color: var(--accent-color);
        transition: color 0.3s ease;
      }

      .input-section {
        margin-bottom: 24px;
        padding: 16px;
        background: var(--bg-tertiary);
        border-radius: 6px;
        transition: background-color 0.3s ease;
      }

      .input-group {
        display: flex;
        gap: 16px;
        align-items: flex-end;
        flex-wrap: wrap;
      }

      .input-field {
        flex: 1;
        min-width: 200px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        font-size: 14px;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      input[type="date"] {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border-light);
        border-radius: 4px;
        font-size: 14px;
        font-family: inherit;
        background: var(--bg-secondary);
        color: var(--text-primary);
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
      }

      input[type="date"]:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px var(--shadow);
      }

      input[type="number"] {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border-light);
        border-radius: 4px;
        font-size: 14px;
        font-family: inherit;
        background: var(--bg-secondary);
        color: var(--text-primary);
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px var(--shadow);
      }

      .checkbox-field {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 12px;
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent-color);
      }

      .checkbox-field label {
        margin-bottom: 0;
        cursor: pointer;
        user-select: none;
      }

      button {
        background: var(--accent-color);
        color: white;
        border: none;
        padding: 10px 24px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: background 0.2s;
      }

      button:hover {
        background: var(--accent-hover);
      }

      button:active {
        background: var(--accent-active);
      }

      button:disabled {
        background: var(--text-tertiary);
        cursor: not-allowed;
      }

      .button-group {
        display: flex;
        gap: 12px;
        margin-top: 16px;
      }

      .secondary-btn {
        background: #757575;
      }

      .secondary-btn:hover {
        background: #616161;
      }

      .report-section {
        margin-top: 24px;
      }

      .report-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }

      .report-stats {
        font-size: 14px;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      .report-content {
        background: var(--bg-code);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 16px;
        min-height: 400px;
        height: 60vh;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-wrap: break-word;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        width: 100%;
        resize: vertical;
        color: var(--text-primary);
      }

      .report-content:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px var(--shadow);
      }

      .report-content::placeholder {
        color: var(--text-tertiary);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      .date-section {
        margin-bottom: 16px;
      }

      .date-header {
        font-weight: bold;
        color: var(--accent-color);
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 2px solid var(--accent-color);
        transition: color 0.3s ease, border-color 0.3s ease;
      }

      .task-item {
        padding-left: 16px;
        margin: 4px 0;
      }

      .no-tasks {
        padding-left: 16px;
        color: var(--text-tertiary);
        font-style: italic;
        transition: color 0.3s ease;
      }

      .loading {
        text-align: center;
        padding: 40px;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }

      .error {
        background: #ffebee;
        color: #c62828;
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 16px;
        border-left: 4px solid #c62828;
      }

      body.dark-theme .error {
        background: #5c1a1a;
        color: #ff8a80;
        border-left-color: #ff5252;
      }

      .info {
        background: #e3f2fd;
        color: #1565c0;
        padding: 12px 16px;
        border-radius: 4px;
        margin-bottom: 16px;
        border-left: 4px solid #1976d2;
        font-size: 14px;
      }

      body.dark-theme .info {
        background: #1a3a52;
        color: #90caf9;
        border-left-color: #42a5f5;
      }

      /* Modal styles */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }

      .modal-overlay.show {
        display: flex;
      }

      .modal {
        background: var(--bg-secondary);
        border-radius: 8px;
        max-width: 900px;
        width: 90%;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 16px var(--shadow-strong);
      }

      .modal-header {
        padding: 20px 24px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: var(--text-secondary);
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
      }

      .modal-close:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .modal-body {
        padding: 24px;
        overflow-y: auto;
        flex: 1;
      }

      .modal-footer {
        padding: 16px 24px;
        border-top: 1px solid var(--border-color);
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .modal-report-content {
        background: var(--bg-code);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 16px;
        min-height: 400px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-wrap: break-word;
        width: 100%;
        resize: vertical;
        color: var(--text-primary);
      }

      .modal-report-content:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px var(--shadow);
      }

      /* Saved reports list */
      .saved-reports-section {
        margin-top: 24px;
        padding: 16px;
        background: var(--bg-tertiary);
        border-radius: 6px;
      }

      .saved-reports-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }

      .saved-reports-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .saved-reports-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .saved-report-item {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        transition: border-color 0.2s;
      }

      .saved-report-item:hover {
        border-color: var(--accent-color);
      }

      .saved-report-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent-color);
      }

      .saved-report-info {
        flex: 1;
        cursor: pointer;
      }

      .saved-report-name {
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 4px;
      }

      .saved-report-meta {
        font-size: 12px;
        color: var(--text-secondary);
      }

      .saved-report-actions {
        display: flex;
        gap: 8px;
      }

      .icon-btn {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 6px;
        border-radius: 4px;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .icon-btn:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .delete-btn:hover {
        color: #d32f2f;
      }

      .empty-state {
        text-align: center;
        padding: 32px;
        color: var(--text-secondary);
        font-style: italic;
      }

      .report-name-input {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border-light);
        border-radius: 4px;
        font-size: 14px;
        font-family: inherit;
        background: var(--bg-secondary);
        color: var(--text-primary);
        margin-bottom: 16px;
      }

      .report-name-input:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px var(--shadow);
      }

      .danger-btn {
        background: #d32f2f;
      }

      .danger-btn:hover {
        background: #c62828;
      }

      .danger-btn:active {
        background: #b71c1c;
      }

      .header-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 24px;
      }

      .header-container h1 {
        margin-bottom: 0;
      }

      .header-container .button-group {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .settings-btn {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, color 0.2s;
      }

      .settings-btn:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header-container">
        <h1>üìä Date Range Task Reporter</h1>
        <div class="button-group">
          <button class="settings-btn" id="settingsBtn" title="Filter Settings">‚öôÔ∏è</button>
          <button id="generateCurrentTasksBtn" class="secondary-btn" title="Current Tasks Report">üìã Current Tasks</button>
        </div>
      </div>

      <div class="info">
        Select a date range to generate a report of all tasks completed or worked on during that period.
      </div>

      <div class="input-section">
        <div class="input-group">
          <div class="input-field">
            <label for="startDate">Start Date</label>
            <input type="date" id="startDate" />
          </div>
          <div class="input-field">
            <label for="endDate">End Date</label>
            <input type="date" id="endDate" />
          </div>
          <button id="generateBtn">Generate Report</button>
        </div>
      </div>

      <!-- Saved Reports Section -->
      <div class="saved-reports-section" id="savedReportsSection">
        <div class="saved-reports-header">
          <h2 class="saved-reports-title">üìÅ Saved Reports</h2>
          <div class="button-group" style="margin-top: 0;">
            <button id="combineSelectedBtn" class="secondary-btn" style="display: none;">üîó Combine Selected</button>
            <button id="deleteSelectedBtn" class="danger-btn" style="display: none;">Delete Selected</button>
          </div>
        </div>
        <div class="saved-reports-list" id="savedReportsList">
          <div class="empty-state">No saved reports yet. Generate and save a report to get started.</div>
        </div>
      </div>
    </div>

    <!-- Report Modal -->
    <div class="modal-overlay" id="reportModal">
      <div class="modal">
        <div class="modal-header">
          <h3 class="modal-title" id="modalTitle">Generated Report</h3>
          <button class="modal-close" id="closeModalBtn">√ó</button>
        </div>
        <div class="modal-body">
          <input type="text" class="report-name-input" id="reportNameInput" placeholder="Report name (optional)" />
          <textarea class="modal-report-content" id="modalReportContent"></textarea>
        </div>
        <div class="modal-footer">
          <button id="modalCopyBtn" class="secondary-btn">üìã Copy to Clipboard</button>
          <button id="modalSaveBtn">üíæ Save Report</button>
        </div>
      </div>
    </div>

    <!-- Preferences Modal -->
    <div class="modal-overlay" id="preferencesModal">
      <div class="modal">
        <div class="modal-header">
          <h3 class="modal-title">‚öôÔ∏è Filter Settings</h3>
          <button class="modal-close" id="closePreferencesBtn">√ó</button>
        </div>
        <div class="modal-body">
          <div class="input-field" style="margin-bottom: 16px;">
            <label for="groupBy">Group by</label>
            <select id="groupBy" style="width: 200px; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); background: var(--bg-secondary); color: var(--text-primary);">
              <option value="date">Date</option>
              <option value="project">Project</option>
            </select>
          </div>
          <div class="checkbox-field" id="showProjectCheckbox">
            <input type="checkbox" id="showProject" />
            <label for="showProject">Show project name with tasks</label>
          </div>
          <div class="checkbox-field" id="showDateCheckbox" style="display: none;">
            <input type="checkbox" id="showDate" />
            <label for="showDate">Show completion date with tasks</label>
          </div>
          <div class="checkbox-field">
            <input type="checkbox" id="excludeEmptyDates" checked />
            <label for="excludeEmptyDates">Exclude dates with no tasks</label>
          </div>
          <div class="checkbox-field">
            <input type="checkbox" id="includeNotes" />
            <label for="includeNotes">Include notes for each task</label>
          </div>
          <div class="checkbox-field">
            <input type="checkbox" id="showTimeSpent" checked />
            <label for="showTimeSpent">Show time spent on tasks</label>
          </div>
          <div class="checkbox-field">
            <input type="checkbox" id="showTotalTime" checked />
            <label for="showTotalTime">Show total time for projects</label>
          </div>
          <div class="input-field" style="margin-top: 16px;">
            <label for="minTimeSpent">Minimum time to include (minutes)</label>
            <input type="number" id="minTimeSpent" min="0" max="60" value="5" style="width: 100px;" />
          </div>
        </div>
        <div class="modal-footer">
          <button id="cancelPreferencesBtn" class="secondary-btn">Cancel</button>
          <button id="savePreferencesBtn">üíæ Save Preferences</button>
        </div>
      </div>
    </div>
  
    <!-- Current Tasks Modal -->
    <div class="modal-overlay" id="currentTasksModal">
      <div class="modal">
        <div class="modal-header">
          <h3 class="modal-title">üìã Current Tasks Report</h3>
          <button class="modal-close" id="closeCurrentTasksModalBtn">√ó</button>
        </div>
        <div class="modal-body">
          <div class="input-section">
            <div class="input-group">
              <div class="input-field">
                <label for="currentTasksStartDate">Due Date Start</label>
                <input type="date" id="currentTasksStartDate" />
              </div>
              <div class="input-field">
                <label for="currentTasksEndDate">Due Date End</label>
                <input type="date" id="currentTasksEndDate" />
              </div>
            </div>
            <div class="input-field" style="margin-top: 16px;">
              <label for="sortBy">Sort by</label>
              <select id="sortBy" style="width: 200px; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); background: var(--bg-secondary); color: var(--text-primary);">
                <option value="dueDate">Due Date</option>
                <option value="project">Project</option>
                <option value="tag">Tag</option>
              </select>
            </div>
            <div class="checkbox-field" style="margin-top: 16px;">
              <input type="checkbox" id="filterByTags" />
              <label for="filterByTags">Filter by Tags</label>
            </div>
            <div id="tagsFilterSection" style="display: none; margin-top: 12px;">
              <label>Select Tags to Filter:</label>
              <div id="tagsCheckboxContainer" style="margin-top: 8px; max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); padding: 8px; border-radius: 4px;"></div>
            </div>
            <button id="generateCurrentTasksReportBtn" style="margin-top: 16px;">Generate Current Tasks Report</button>
          </div>
          <textarea class="modal-report-content" id="currentTasksReportContent" placeholder="Current tasks report will appear here..."></textarea>
        </div>
        <div class="modal-footer">
          <button id="currentTasksCopyBtn" class="secondary-btn">üìã Copy to Clipboard</button>
          <button id="currentTasksSaveBtn">üíæ Save Report</button>
        </div>
      </div>
    </div>
  
    <script>
      // Theme detection and management
      function detectTheme() {
        try {
          // Check if parent window has dark theme class
          if (window.parent && window.parent.document) {
            const parentBody = window.parent.document.body;
            const isDark = parentBody.classList.contains('dark-theme') || 
                          parentBody.classList.contains('isDarkTheme') ||
                          parentBody.getAttribute('data-theme') === 'dark';
            
            if (isDark) {
              document.body.classList.add('dark-theme');
            } else {
              document.body.classList.remove('dark-theme');
            }
          }
        } catch (e) {
          // If we can't access parent (cross-origin), check system preference
          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark-theme');
          }
        }
      }

      // Watch for theme changes in parent
      function watchThemeChanges() {
        try {
          if (window.parent && window.parent.document) {
            const observer = new MutationObserver(detectTheme);
            observer.observe(window.parent.document.body, {
              attributes: true,
              attributeFilter: ['class', 'data-theme']
            });
          }
        } catch (e) {
          // Can't observe parent, use media query instead
          if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addListener(detectTheme);
          }
        }
      }

      // Initialize theme on load
      detectTheme();
      watchThemeChanges();

      // Initialize dates
      const today = new Date();

      const startDateInput = document.getElementById('startDate');
      const endDateInput = document.getElementById('endDate');
      const generateBtn = document.getElementById('generateBtn');
      const groupBySelect = document.getElementById('groupBy');
      const showProjectCheckbox = document.getElementById('showProject');
      const showDateCheckbox = document.getElementById('showDate');
      const showProjectCheckboxContainer = document.getElementById('showProjectCheckbox');
      const showDateCheckboxContainer = document.getElementById('showDateCheckbox');
      const excludeEmptyDatesCheckbox = document.getElementById('excludeEmptyDates');
      const includeNotesCheckbox = document.getElementById('includeNotes');
      const minTimeSpentInput = document.getElementById('minTimeSpent');
      const showTimeSpentCheckbox = document.getElementById('showTimeSpent');
      const showTotalTimeCheckbox = document.getElementById('showTotalTime');
      
      // Modal elements
      const reportModal = document.getElementById('reportModal');
      const closeModalBtn = document.getElementById('closeModalBtn');
      const modalTitle = document.getElementById('modalTitle');
      const modalReportContent = document.getElementById('modalReportContent');
      const modalCopyBtn = document.getElementById('modalCopyBtn');
      const modalSaveBtn = document.getElementById('modalSaveBtn');
      const reportNameInput = document.getElementById('reportNameInput');

      // Current tasks modal elements
      const currentTasksModal = document.getElementById('currentTasksModal');
      const closeCurrentTasksModalBtn = document.getElementById('closeCurrentTasksModalBtn');
      const currentTasksStartDate = document.getElementById('currentTasksStartDate');
      const currentTasksEndDate = document.getElementById('currentTasksEndDate');
      const filterByTagsCheckbox = document.getElementById('filterByTags');
      const tagsFilterSection = document.getElementById('tagsFilterSection');
      const tagsCheckboxContainer = document.getElementById('tagsCheckboxContainer');
      const generateCurrentTasksReportBtn = document.getElementById('generateCurrentTasksReportBtn');
      const currentTasksReportContent = document.getElementById('currentTasksReportContent');
      const currentTasksCopyBtn = document.getElementById('currentTasksCopyBtn');
      const currentTasksSaveBtn = document.getElementById('currentTasksSaveBtn');
      const generateCurrentTasksBtn = document.getElementById('generateCurrentTasksBtn');
      const sortBySelect = document.getElementById('sortBy');

      // Preferences modal elements
      const preferencesModal = document.getElementById('preferencesModal');
      const closePreferencesBtn = document.getElementById('closePreferencesBtn');
      const cancelPreferencesBtn = document.getElementById('cancelPreferencesBtn');
      const savePreferencesBtn = document.getElementById('savePreferencesBtn');
      const settingsBtn = document.getElementById('settingsBtn');

      // Saved reports elements
      const savedReportsSection = document.getElementById('savedReportsSection');
      const savedReportsList = document.getElementById('savedReportsList');
      const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
      const combineSelectedBtn = document.getElementById('combineSelectedBtn');

      // State
      let savedReports = [];
      let currentReport = null;
      let isEditingExisting = false;
      let preferences = {
        groupBy: 'date',
        showProject: false,
        showDate: false,
        excludeEmptyDates: true,
        includeNotes: false,
        minTimeSpent: 5,
        showTimeSpent: true,
        showTotalTime: true,
        // Current tasks preferences
        currentTasksShowProject: true,
        currentTasksShowDueDate: true,
        currentTasksShowTags: true,
        currentTasksShowEstimate: true,
        currentTasksShowNotes: true,
        currentTasksShowSubtasks: true
      };

      // Set default dates to past seven days (including today)
      const sevenDaysAgo = new Date(today);
      sevenDaysAgo.setDate(today.getDate() - 6);
      startDateInput.valueAsDate = sevenDaysAgo;
      endDateInput.valueAsDate = today;

      // Format date as YYYY-MM-DD
      function formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      // Format date for display (e.g., "Monday, January 1, 2024")
      function formatDateDisplay(dateStr) {
        const date = new Date(dateStr + 'T00:00:00');
        const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
      }

      // Format time in minutes to human readable format (e.g., "1h 30m" or "45m")
      function formatTime(minutes) {
        if (minutes < 60) {
          return `${minutes}m`;
        }
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
      }

      // Get all dates in range
      function getDateRange(startDate, endDate) {
        const dates = [];
        const currentDate = new Date(startDate + 'T00:00:00');
        const end = new Date(endDate + 'T00:00:00');

        while (currentDate <= end) {
          dates.push(formatDate(currentDate));
          currentDate.setDate(currentDate.getDate() + 1);
        }

        return dates;
      }

      // Generate report grouped by date
      function generateReportByDate(allTasks, startDate, endDate, projects, showProject) {
        const tasksByDate = {};
        let totalTasks = 0;

        // Get all dates in range
        const dateRange = getDateRange(formatDate(startDate), formatDate(endDate));
        dateRange.forEach(date => {
          tasksByDate[date] = [];
        });

        // Process all tasks (both archived and active)
        const processedTasks = new Set(); // Track tasks to avoid duplicates
        const minTimeMs = parseInt(minTimeSpentInput.value) * 60000; // Convert minutes to milliseconds
        let excludedWorkLogCount = 0; // Track excluded work logs
        
        allTasks.forEach(task => {
          // Check if task has work logs
          const hasWorkLogs = task.timeSpentOnDay && Object.keys(task.timeSpentOnDay).length > 0;
          
          if (task.isDone && task.doneOn) {
            const taskDate = new Date(task.doneOn);
            const taskDateStr = formatDate(taskDate);
            
            // Check if task completion is in date range
            const isCompletionInRange = taskDateStr >= formatDate(startDate) && taskDateStr <= formatDate(endDate);
            
            // Get work logs within date range that meet minimum time threshold
            const workLogsInRange = hasWorkLogs 
              ? Object.keys(task.timeSpentOnDay).filter(date => {
                  const isInRange = date >= formatDate(startDate) && date <= formatDate(endDate);
                  const meetsMinTime = task.timeSpentOnDay[date] >= minTimeMs;
                  if (isInRange && !meetsMinTime) {
                    excludedWorkLogCount++;
                  }
                  return isInRange && meetsMinTime;
                }).sort()
              : [];
            
            // If task has multiple work logs, show each work log as a separate entry
            if (workLogsInRange.length > 1) {
              workLogsInRange.forEach(workLogDate => {
                if (!tasksByDate[workLogDate]) {
                  tasksByDate[workLogDate] = [];
                }
                
                // Work logs before completion date get WIP indicator
                const isWorkLogBeforeCompletion = workLogDate !== taskDateStr;
                const taskEntry = { 
                  ...task, 
                  isInProgress: isWorkLogBeforeCompletion,
                  workLogDate: workLogDate
                };
                tasksByDate[workLogDate].push(taskEntry);
              });
              
              if (!processedTasks.has(task.id)) {
                totalTasks++;
                processedTasks.add(task.id);
              }
            }
            // Task with one or no work logs - show normally on completion date if in range
            else if (isCompletionInRange) {
              if (!tasksByDate[taskDateStr]) {
                tasksByDate[taskDateStr] = [];
              }
              tasksByDate[taskDateStr].push(task);
              if (!processedTasks.has(task.id)) {
                totalTasks++;
                processedTasks.add(task.id);
              }
            }
          }
          // Include tasks with work logs in the date range (even if not completed)
          else if (hasWorkLogs) {
            // Check each date in the task's work logs
            Object.keys(task.timeSpentOnDay).forEach(workLogDate => {
              // Check if work log date is in the report date range
              const isInRange = workLogDate >= formatDate(startDate) && workLogDate <= formatDate(endDate);
              const meetsMinTime = task.timeSpentOnDay[workLogDate] >= minTimeMs;
              
              if (isInRange && !meetsMinTime) {
                excludedWorkLogCount++;
              }
              
              if (isInRange && meetsMinTime) {
                if (!tasksByDate[workLogDate]) {
                  tasksByDate[workLogDate] = [];
                }
                // Mark task as in-progress to differentiate from completed tasks
                const taskWithStatus = { ...task, isInProgress: true, workLogDate: workLogDate };
                tasksByDate[workLogDate].push(taskWithStatus);
                if (!processedTasks.has(task.id)) {
                  totalTasks++;
                  processedTasks.add(task.id);
                }
              }
            });
          }
        });

        // Generate report in Markdown format
        let reportText = `# Task Completion Report\n\n`;
        reportText += `**Date Range:** ${formatDateDisplay(formatDate(startDate))} - ${formatDateDisplay(formatDate(endDate))}  \n`;
        reportText += `**Generated:** ${new Date().toLocaleString()}  \n`;
        reportText += `**Total Tasks:** ${totalTasks}\n`;
        if (excludedWorkLogCount > 0) {
          reportText += `**Excluded Work Logs:** ${excludedWorkLogCount} (below ${minTimeSpentInput.value} min threshold)\n`;
        }
        reportText += `*Note: Individual work log entries are shown for tasks with multiple work logs. WIP indicates work in progress.*\n\n`;
        reportText += `---\n\n`;

        // Sort dates
        const sortedDates = Object.keys(tasksByDate).sort();

        // Filter out empty dates if checkbox is checked
        const excludeEmpty = excludeEmptyDatesCheckbox.checked;
        const includeNotes = includeNotesCheckbox.checked;
        const datesToShow = excludeEmpty 
          ? sortedDates.filter(dateStr => tasksByDate[dateStr].length > 0)
          : sortedDates;

        datesToShow.forEach(dateStr => {
          const tasks = tasksByDate[dateStr];
          reportText += `## ${formatDateDisplay(dateStr)}\n\n`;

          if (tasks.length === 0) {
            reportText += `*No tasks*\n\n`;
          } else {
            tasks.forEach((task, index) => {
              // Use workLogDate if available, otherwise use the date from the section
              const dateForTimeSpent = task.workLogDate || dateStr;
              const timeSpent = (showTimeSpentCheckbox.checked && task.timeSpentOnDay && task.timeSpentOnDay[dateForTimeSpent])
                ? ` *(${Math.round(task.timeSpentOnDay[dateForTimeSpent] / 60000)} min)*`
                : '';
              // Show status indicator for in-progress tasks
              const statusIndicator = task.isInProgress ? ' WIP' : '';
              
              // Optionally show project name
              const projectName = showProject && task.projectId && projects[task.projectId] 
                ? ` [${projects[task.projectId]}]` 
                : '';
              
              reportText += `- ${task.title}${projectName}${timeSpent}${statusIndicator}\n`;
              
              // Include notes if checkbox is checked and task has notes
              if (includeNotes && task.notes && task.notes.trim()) {
                // Indent the notes for better formatting
                const indentedNotes = task.notes.trim().split('\n').map(line => `  ${line}`).join('\n');
                reportText += `${indentedNotes}\n`;
              }
            });
            reportText += `\n`;
          }
        });

        return { reportText, totalTasks };
      }

      // Generate report grouped by project
      function generateReportByProject(allTasks, startDate, endDate, projects, showDate) {
        const tasksByProject = {};
        const processedTasks = new Set();
        let totalTasks = 0;
        const minTimeMs = parseInt(minTimeSpentInput.value) * 60000;
        let excludedWorkLogCount = 0;

        // Process all tasks
        allTasks.forEach(task => {
          const hasWorkLogs = task.timeSpentOnDay && Object.keys(task.timeSpentOnDay).length > 0;
          
          // Aggregate time spent on this task within the date range
          let totalTimeSpent = 0;
          let taskDates = [];
          
          if (hasWorkLogs) {
            Object.keys(task.timeSpentOnDay).forEach(workLogDate => {
              const isInRange = workLogDate >= formatDate(startDate) && workLogDate <= formatDate(endDate);
              if (isInRange) {
                const timeSpent = task.timeSpentOnDay[workLogDate];
                if (timeSpent >= minTimeMs) {
                  totalTimeSpent += timeSpent;
                  taskDates.push(workLogDate);
                } else {
                  excludedWorkLogCount++;
                }
              }
            });
          }
          
          // Only include tasks that have time spent in the range or are completed in the range
          const isCompletedInRange = task.isDone && task.doneOn && 
            formatDate(new Date(task.doneOn)) >= formatDate(startDate) && 
            formatDate(new Date(task.doneOn)) <= formatDate(endDate);
          
          if ((totalTimeSpent > 0 || isCompletedInRange) && !processedTasks.has(task.id)) {
            const projectId = task.projectId || 'no-project';
            const projectName = projects[projectId] || 'No Project';
            
            if (!tasksByProject[projectId]) {
              tasksByProject[projectId] = {
                name: projectName,
                tasks: [],
                totalTime: 0
              };
            }
            
            tasksByProject[projectId].tasks.push({
              ...task,
              totalTimeSpent,
              dates: taskDates,
              isInProgress: !task.isDone
            });
            tasksByProject[projectId].totalTime += totalTimeSpent;
            
            processedTasks.add(task.id);
            totalTasks++;
          }
        });

        // Generate report in Markdown format
        let reportText = `# Task Completion Report\n\n`;
        reportText += `**Date Range:** ${formatDateDisplay(formatDate(startDate))} - ${formatDateDisplay(formatDate(endDate))}  \n`;
        reportText += `**Generated:** ${new Date().toLocaleString()}  \n`;
        reportText += `**Total Tasks:** ${totalTasks}\n`;
        if (excludedWorkLogCount > 0) {
          reportText += `**Excluded Work Logs:** ${excludedWorkLogCount} (below ${minTimeSpentInput.value} min threshold)\n`;
        }
        reportText += `*Note: Tasks are grouped by project. Time shown is the total across all days in the date range.*\n\n`;
        reportText += `---\n\n`;

        // Sort projects by name
        const sortedProjects = Object.keys(tasksByProject).sort((a, b) => {
          const nameA = tasksByProject[a].name.toLowerCase();
          const nameB = tasksByProject[b].name.toLowerCase();
          return nameA.localeCompare(nameB);
        });

        // Filter out empty projects if checkbox is checked
        const excludeEmpty = excludeEmptyDatesCheckbox.checked;
        const includeNotes = includeNotesCheckbox.checked;
        const projectsToShow = excludeEmpty 
          ? sortedProjects.filter(projectId => tasksByProject[projectId].tasks.length > 0)
          : sortedProjects;

        projectsToShow.forEach(projectId => {
          const project = tasksByProject[projectId];
          const totalMinutes = Math.round(project.totalTime / 60000);
          const formattedTime = formatTime(totalMinutes);
          
          const totalTimeDisplay = showTotalTimeCheckbox.checked ? ` *(total: ${formattedTime})*` : '';
          reportText += `## ${project.name}${totalTimeDisplay}\n\n`;

          if (project.tasks.length === 0) {
            reportText += `*No tasks*\n\n`;
          } else {
            project.tasks.forEach(task => {
              const timeMinutes = Math.round(task.totalTimeSpent / 60000);
              const timeSpent = (showTimeSpentCheckbox.checked && timeMinutes > 0) ? ` *(${formatTime(timeMinutes)})*` : '';
              const statusIndicator = task.isInProgress ? ' WIP' : '';
              
              // Optionally show completion date
              let dateInfo = '';
              if (showDate) {
                if (task.isDone && task.doneOn) {
                  const completionDate = formatDate(new Date(task.doneOn));
                  dateInfo = ` [${formatDateDisplay(completionDate)}]`;
                } else if (task.dates && task.dates.length > 0) {
                  // Show the latest work log date for WIP tasks
                  const latestDate = task.dates.sort().pop();
                  dateInfo = ` [Last worked: ${formatDateDisplay(latestDate)}]`;
                }
              }
              
              reportText += `  - ${task.title}${dateInfo}${timeSpent}${statusIndicator}\n`;
              
              // Include notes if checkbox is checked and task has notes
              if (includeNotes && task.notes && task.notes.trim()) {
                // Indent the notes for better formatting (extra indent for project grouping)
                const indentedNotes = task.notes.trim().split('\n').map(line => `    ${line}`).join('\n');
                reportText += `${indentedNotes}\n`;
              }
            });
            reportText += `\n`;
          }
        });

        return { reportText, totalTasks };
      }

      // Fetch current tasks data
      async function fetchCurrentTasksData() {
        try {
          // Get all active tasks (non-completed)
          const allTasks = await PluginAPI.getTasks();
          
          // Create a map of all tasks by ID for subtask lookup
          const tasksMap = {};
          allTasks.forEach(task => {
            tasksMap[task.id] = task;
          });
          
          // Create a set of all subtask IDs to filter them out from main list
          const subtaskIds = new Set();
          allTasks.forEach(task => {
            if (task.subTaskIds && task.subTaskIds.length > 0) {
              task.subTaskIds.forEach(subId => subtaskIds.add(subId));
            }
          });
          
          // Filter to get only non-completed tasks that are NOT subtasks
          const currentTasks = allTasks.filter(task => !task.isDone && !subtaskIds.has(task.id));

          // Get all tags for tag name resolution
          const allTags = await PluginAPI.getAllTags();
          const tagsMap = {};
          allTags.forEach(tag => {
            tagsMap[tag.id] = tag.title;
          });

          // Get all projects for project name resolution
          const allProjects = await PluginAPI.getAllProjects();
          const projectsMap = {};
          allProjects.forEach(project => {
            projectsMap[project.id] = project.title;
          });

          return {
            currentTasks,
            tagsMap,
            projectsMap,
            allTags,
            tasksMap
          };
        } catch (error) {
          console.error('Error fetching current tasks data:', error);
          throw error;
        }
      }

      // Generate current tasks report
      function generateCurrentTasksReport(currentTasks, tagsMap, projectsMap, startDate, endDate, selectedTagIds, tasksMap, sortBy = 'dueDate') {
        // Filter tasks by due date range if dates are provided
        let filteredTasks = [...currentTasks];

        if (startDate && endDate) {
          filteredTasks = filteredTasks.filter(task => {
            // If task has no due date, include it when filtering by date range
            // (user might want to see tasks without due dates too)
            if (!task.dueOn) return true;
            const taskDate = new Date(task.dueOn);
            const taskDateStr = formatDate(taskDate);
            return taskDateStr >= startDate && taskDateStr <= endDate;
          });
        }

        // Filter by selected tags if any are selected
        if (selectedTagIds && selectedTagIds.length > 0) {
          filteredTasks = filteredTasks.filter(task => {
            if (!task.tagIds || task.tagIds.length === 0) return false;
            return task.tagIds.some(tagId => selectedTagIds.includes(tagId));
          });
        }

        // Sort tasks based on selected sort option
        if (sortBy === 'project') {
          filteredTasks.sort((a, b) => {
            const projectA = projectsMap[a.projectId] || 'No Project';
            const projectB = projectsMap[b.projectId] || 'No Project';
            return projectA.localeCompare(projectB);
          });
        } else if (sortBy === 'tag') {
          filteredTasks.sort((a, b) => {
            const tagA = a.tagIds && a.tagIds.length > 0 ? tagsMap[a.tagIds[0]] || '' : '';
            const tagB = b.tagIds && b.tagIds.length > 0 ? tagsMap[b.tagIds[0]] || '' : '';
            return tagA.localeCompare(tagB);
          });
        } else {
          // Default: sort by due date
          filteredTasks.sort((a, b) => {
            if (!a.dueOn && !b.dueOn) return 0;
            if (!a.dueOn) return 1;
            if (!b.dueOn) return -1;
            return new Date(a.dueOn) - new Date(b.dueOn);
          });
        }

        // Generate report in Markdown format
        let reportText = `# Current Tasks Report\n\n`;
        reportText += `**Generated:** ${new Date().toLocaleString()}  \n`;
        reportText += `**Total Current Tasks:** ${filteredTasks.length}\n`;

        if (startDate && endDate) {
          reportText += `**Due Date Range:** ${formatDateDisplay(startDate)} - ${formatDateDisplay(endDate)}\n`;
        }

        if (selectedTagIds && selectedTagIds.length > 0) {
          const selectedTagNames = selectedTagIds.map(id => tagsMap[id] || `Tag ${id}`).join(', ');
          reportText += `**Filtered by Tags:** ${selectedTagNames}\n`;
        }

        reportText += `**Sort Order:** ${sortBy === 'project' ? 'Project' : sortBy === 'tag' ? 'Tag' : 'Due Date'}\n`;
        reportText += `---\n\n`;

        // Group tasks based on sort option
        if (sortBy === 'project') {
          // Group by project
          const tasksByProject = {};
          filteredTasks.forEach(task => {
            const projectName = projectsMap[task.projectId] || 'No Project';
            if (!tasksByProject[projectName]) {
              tasksByProject[projectName] = [];
            }
            tasksByProject[projectName].push(task);
          });

          Object.keys(tasksByProject).sort().forEach(projectName => {
            const tasks = tasksByProject[projectName];
            reportText += `## ${projectName}\n\n`;
            tasks.forEach(task => {
              reportText += generateTaskReportEntry(task, tagsMap, projectsMap, 0, tasksMap);
            });
            reportText += `\n`;
          });
        } else if (sortBy === 'tag') {
          // Group by primary tag
          const tasksByTag = {};
          const noTagTasks = [];
          
          filteredTasks.forEach(task => {
            if (task.tagIds && task.tagIds.length > 0) {
              const tagName = tagsMap[task.tagIds[0]] || 'Unknown Tag';
              if (!tasksByTag[tagName]) {
                tasksByTag[tagName] = [];
              }
              tasksByTag[tagName].push(task);
            } else {
              noTagTasks.push(task);
            }
          });

          Object.keys(tasksByTag).sort().forEach(tagName => {
            const tasks = tasksByTag[tagName];
            reportText += `## ${tagName}\n\n`;
            tasks.forEach(task => {
              reportText += generateTaskReportEntry(task, tagsMap, projectsMap, 0, tasksMap);
            });
            reportText += `\n`;
          });

          if (noTagTasks.length > 0) {
            reportText += `## No Tags\n\n`;
            noTagTasks.forEach(task => {
              reportText += generateTaskReportEntry(task, tagsMap, projectsMap, 0, tasksMap);
            });
          }
        } else {
          // Group by due date (default)
          const tasksByDate = {};
          const noDueDateTasks = [];

          filteredTasks.forEach(task => {
            if (task.dueOn) {
              const taskDate = new Date(task.dueOn);
              const dateStr = formatDate(taskDate);
              if (!tasksByDate[dateStr]) {
                tasksByDate[dateStr] = [];
              }
              tasksByDate[dateStr].push(task);
            } else {
              noDueDateTasks.push(task);
            }
          });

          // Add tasks with due dates
          Object.keys(tasksByDate).sort().forEach(dateStr => {
            const tasks = tasksByDate[dateStr];
            reportText += `## ${formatDateDisplay(dateStr)}\n\n`;
            tasks.forEach(task => {
              reportText += generateTaskReportEntry(task, tagsMap, projectsMap, 0, tasksMap);
            });
            reportText += `\n`;
          });

          // Add tasks without due dates
          if (noDueDateTasks.length > 0) {
            reportText += `## No Due Date\n\n`;
            noDueDateTasks.forEach(task => {
              reportText += generateTaskReportEntry(task, tagsMap, projectsMap, 0, tasksMap);
            });
          }
        }

        return reportText;
      }

      // Helper function to generate individual task report entry
      function generateTaskReportEntry(task, tagsMap, projectsMap, indentLevel = 0, tasksMap = {}) {
        const indent = '  '.repeat(indentLevel);
        // Trim the task title to remove trailing spaces that break markdown formatting
        const taskTitle = task.title.trim();
        let reportEntry = `${indent}- **${taskTitle}**\n`;

        // Add project if available and preference is enabled
        if (preferences.currentTasksShowProject && task.projectId && projectsMap[task.projectId]) {
          reportEntry += `${indent}  *Project:* ${projectsMap[task.projectId]}\n`;
        }

        // Add due date if available and preference is enabled
        if (preferences.currentTasksShowDueDate && task.dueOn) {
          const dueDate = new Date(task.dueOn);
          reportEntry += `${indent}  *Due:* ${formatDateDisplay(formatDate(dueDate))}\n`;
        }

        // Add tags if available and preference is enabled
        if (preferences.currentTasksShowTags && task.tagIds && task.tagIds.length > 0) {
          const tagNames = task.tagIds.map(id => tagsMap[id] || `Tag ${id}`).join(', ');
          reportEntry += `${indent}  *Tags:* ${tagNames}\n`;
        }

        // Add time estimate if available and preference is enabled
        if (preferences.currentTasksShowEstimate && task.timeEstimate) {
          const estimateMinutes = Math.round(task.timeEstimate / 60000);
          reportEntry += `${indent}  *Estimate:* ${formatTime(estimateMinutes)}\n`;
        }

        // Add notes/description if available and preference is enabled
        if (preferences.currentTasksShowNotes && task.notes && task.notes.trim()) {
          const indentedNotes = task.notes.trim().split('\n').map(line => `${indent}  ${line}`).join('\n');
          reportEntry += `${indent}  *Notes:*\n${indentedNotes}\n`;
        }

        // Add subtasks if available and preference is enabled
        if (preferences.currentTasksShowSubtasks && task.subTaskIds && task.subTaskIds.length > 0) {
          reportEntry += `${indent}  *Subtasks:*\n`;
          task.subTaskIds.forEach(subTaskId => {
            const subTask = tasksMap[subTaskId];
            if (subTask) {
              const checkmark = subTask.isDone ? '‚úì' : '‚óã';
              reportEntry += `${indent}    ${checkmark} ${subTask.title}\n`;
            } else {
              reportEntry += `${indent}    - Subtask ${subTaskId}\n`;
            }
          });
        }

        return reportEntry;
      }

      // Generate report
      async function generateReport() {
        try {
          generateBtn.disabled = true;
          generateBtn.textContent = 'Generating...';

          const startDate = new Date(startDateInput.value + 'T00:00:00');
          const endDate = new Date(endDateInput.value + 'T23:59:59');

          if (startDate > endDate) {
            PluginAPI.showSnack({
              msg: 'Start date must be before or equal to end date',
              type: 'ERROR',
            });
            return;
          }

          // Get both archived and active tasks (completed tasks may not be archived)
          const archivedTasks = await PluginAPI.getArchivedTasks();
          const activeTasks = await PluginAPI.getTasks();
          
          // Get all projects to map projectId to project name
          const projects = {};
          try {
            const allProjects = await PluginAPI.getAllProjects();
            allProjects.forEach(project => {
              projects[project.id] = project.title;
            });
          } catch (e) {
            console.warn('Could not load projects:', e);
          }
          
          // Combine all tasks
          const allTasks = [...archivedTasks, ...activeTasks];

          const groupBy = groupBySelect.value;
          const showProject = showProjectCheckbox.checked;
          const showDate = showDateCheckbox.checked;
          
          let reportText = '';
          let totalTasks = 0;
          
          if (groupBy === 'date') {
            // Group by date logic (existing logic with optional project display)
            const result = generateReportByDate(allTasks, startDate, endDate, projects, showProject);
            reportText = result.reportText;
            totalTasks = result.totalTasks;
          } else {
            // Group by project logic
            const result = generateReportByProject(allTasks, startDate, endDate, projects, showDate);
            reportText = result.reportText;
            totalTasks = result.totalTasks;
          }

          // Store report data and show modal
          currentReport = {
            content: reportText,
            startDate: startDateInput.value,
            endDate: endDateInput.value,
            totalTasks: totalTasks,
            generatedAt: new Date().toISOString()
          };

          isEditingExisting = false;
          showReportModal(reportText, `${totalTasks} task${totalTasks !== 1 ? 's' : ''} completed`);

          PluginAPI.showSnack({
            msg: `Report generated with ${totalTasks} tasks`,
            type: 'SUCCESS',
          });

        } catch (error) {
          console.error('Error generating report:', error);
          PluginAPI.showSnack({
            msg: 'Failed to generate report: ' + error.message,
            type: 'ERROR',
          });
        } finally {
          generateBtn.disabled = false;
          generateBtn.textContent = 'Generate Report';
        }
      }

      // Show report modal
      function showReportModal(reportText, subtitle = '') {
        modalTitle.textContent = isEditingExisting ? 'Edit Saved Report' : 'Generated Report';
        if (subtitle && !isEditingExisting) {
          modalTitle.textContent += ` - ${subtitle}`;
        }
        modalReportContent.value = reportText;
        reportNameInput.value = currentReport.name || '';
        reportModal.classList.add('show');
      }

      // Hide report modal
      function hideReportModal() {
        reportModal.classList.remove('show');
        reportNameInput.value = '';
        currentReport = null;
        isEditingExisting = false;
      }

      // Copy to clipboard from modal
      async function copyFromModal() {
        try {
          const text = modalReportContent.value;
          await navigator.clipboard.writeText(text);

          PluginAPI.showSnack({
            msg: 'Report copied to clipboard!',
            type: 'SUCCESS',
            ico: 'content_copy',
          });
        } catch (error) {
          console.error('Error copying to clipboard:', error);
          PluginAPI.showSnack({
            msg: 'Failed to copy to clipboard',
            type: 'ERROR',
          });
        }
      }

      // Save report
      async function saveReport() {
        try {
          const reportContent = modalReportContent.value;
          const currentTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const reportName = reportNameInput.value.trim() || `Report ${formatDateDisplay(currentReport.startDate)} - ${formatDateDisplay(currentReport.endDate)} at ${currentTime}`;

          if (isEditingExisting) {
            // Update existing report
            const existingIndex = savedReports.findIndex(r => r.id === currentReport.id);
            if (existingIndex !== -1) {
              savedReports[existingIndex] = {
                ...savedReports[existingIndex],
                name: reportName,
                content: reportContent,
                updatedAt: new Date().toISOString()
              };
            }
          } else {
            // Create new report
            const newReport = {
              id: Date.now().toString(),
              name: reportName,
              content: reportContent,
              startDate: currentReport.startDate,
              endDate: currentReport.endDate,
              totalTasks: currentReport.totalTasks,
              generatedAt: currentReport.generatedAt,
              savedAt: new Date().toISOString()
            };
            savedReports.unshift(newReport);
          }

          await persistReports();
          renderSavedReports();
          hideReportModal();

          PluginAPI.showSnack({
            msg: isEditingExisting ? 'Report updated successfully!' : 'Report saved successfully!',
            type: 'SUCCESS',
            ico: 'save',
          });
        } catch (error) {
          console.error('Error saving report:', error);
          PluginAPI.showSnack({
            msg: 'Failed to save report',
            type: 'ERROR',
          });
        }
      }

      // Show current tasks modal
      function showCurrentTasksModal() {
        currentTasksModal.classList.add('show');
        // Set default dates to next 7 days
        const today = new Date();
        currentTasksStartDate.valueAsDate = today;
        const sevenDaysLater = new Date(today);
        sevenDaysLater.setDate(today.getDate() + 6);
        currentTasksEndDate.valueAsDate = sevenDaysLater;
      }

      // Hide current tasks modal
      function hideCurrentTasksModal() {
        currentTasksModal.classList.remove('show');
        currentTasksReportContent.value = '';
      }

      // Generate current tasks report
      async function generateCurrentTasksReportAsync() {
        try {
          generateCurrentTasksReportBtn.disabled = true;
          generateCurrentTasksReportBtn.textContent = 'Generating...';

          const startDate = currentTasksStartDate.value;
          const endDate = currentTasksEndDate.value;

          if (startDate && endDate && new Date(startDate) > new Date(endDate)) {
            PluginAPI.showSnack({
              msg: 'Start date must be before or equal to end date',
              type: 'ERROR',
            });
            return;
          }

          // Fetch current tasks data
          const { currentTasks, tagsMap, projectsMap, allTags, tasksMap } = await fetchCurrentTasksData();

          // Get selected tags if filtering by tags
          let selectedTagIds = [];
          if (filterByTagsCheckbox.checked) {
            const tagCheckboxes = document.querySelectorAll('#tagsCheckboxContainer input[type="checkbox"]:checked');
            selectedTagIds = Array.from(tagCheckboxes).map(cb => cb.value);
          }

          // Get sort option
          const sortBy = sortBySelect.value;

          // Generate report (this is a synchronous function that returns a string)
          const reportText = generateCurrentTasksReport(
            currentTasks,
            tagsMap,
            projectsMap,
            startDate,
            endDate,
            selectedTagIds,
            tasksMap,
            sortBy
          );

          currentTasksReportContent.value = reportText;

          // Count the actual filtered tasks in the report
          const filteredCount = reportText.match(/^- \*\*/gm)?.length || 0;

          PluginAPI.showSnack({
            msg: `Current tasks report generated with ${filteredCount} tasks`,
            type: 'SUCCESS',
          });

        } catch (error) {
          console.error('Error generating current tasks report:', error);
          PluginAPI.showSnack({
            msg: 'Failed to generate current tasks report: ' + error.message,
            type: 'ERROR',
          });
        } finally {
          generateCurrentTasksReportBtn.disabled = false;
          generateCurrentTasksReportBtn.textContent = 'Generate Current Tasks Report';
        }
      }

      // Copy current tasks report to clipboard
      async function copyCurrentTasksReport() {
        try {
          const text = currentTasksReportContent.value;
          await navigator.clipboard.writeText(text);

          PluginAPI.showSnack({
            msg: 'Current tasks report copied to clipboard!',
            type: 'SUCCESS',
            ico: 'content_copy',
          });
        } catch (error) {
          console.error('Error copying current tasks report to clipboard:', error);
          PluginAPI.showSnack({
            msg: 'Failed to copy current tasks report to clipboard',
            type: 'ERROR',
          });
        }
      }

      // Save current tasks report
      async function saveCurrentTasksReport() {
        try {
          const reportContent = currentTasksReportContent.value;
          const currentTime = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const reportName = `Current Tasks Report - ${formatDate(new Date())} at ${currentTime}`;

          const newReport = {
            id: Date.now().toString(),
            name: reportName,
            content: reportContent,
            type: 'current-tasks',
            savedAt: new Date().toISOString()
          };

          savedReports.unshift(newReport);
          await persistReports();
          renderSavedReports();
          hideCurrentTasksModal();

          PluginAPI.showSnack({
            msg: 'Current tasks report saved successfully!',
            type: 'SUCCESS',
            ico: 'save',
          });
        } catch (error) {
          console.error('Error saving current tasks report:', error);
          PluginAPI.showSnack({
            msg: 'Failed to save current tasks report',
            type: 'ERROR',
          });
        }
      }

      // Load tags and populate filter section
      async function loadTagsForFilter() {
        try {
          const { allTags } = await fetchCurrentTasksData();

          if (allTags.length === 0) {
            tagsCheckboxContainer.innerHTML = '<div class="empty-state">No tags available</div>';
            return;
          }

          tagsCheckboxContainer.innerHTML = allTags.map(tag => `
            <div class="checkbox-field" style="margin: 4px 0;">
              <input type="checkbox" id="tag-${tag.id}" value="${tag.id}" />
              <label for="tag-${tag.id}">${tag.title}</label>
            </div>
          `).join('');

        } catch (error) {
          console.error('Error loading tags for filter:', error);
          tagsCheckboxContainer.innerHTML = '<div class="error">Failed to load tags</div>';
        }
      }

      // Toggle tags filter section visibility
      function toggleTagsFilter() {
        if (filterByTagsCheckbox.checked) {
          tagsFilterSection.style.display = 'block';
          loadTagsForFilter();
        } else {
          tagsFilterSection.style.display = 'none';
        }
      }

      // Load reports from storage
      async function loadReports() {
        try {
          const data = await PluginAPI.loadSyncedData();
          if (data) {
            const parsed = JSON.parse(data);
            // Support both old format (array) and new format (object with reports and preferences)
            if (Array.isArray(parsed)) {
              savedReports = parsed;
            } else {
              savedReports = parsed.reports || [];
              if (parsed.preferences) {
                preferences = { ...preferences, ...parsed.preferences };
                applyPreferences();
              }
            }
          }
          renderSavedReports();
        } catch (error) {
          console.error('Error loading reports:', error);
        }
      }

      // Persist reports to storage
      async function persistReports() {
        try {
          const data = {
            reports: savedReports,
            preferences: preferences
          };
          await PluginAPI.persistDataSynced(JSON.stringify(data));
        } catch (error) {
          console.error('Error persisting reports:', error);
          throw error;
        }
      }

      // Load preferences and apply to UI
      function applyPreferences() {
        groupBySelect.value = preferences.groupBy;
        showProjectCheckbox.checked = preferences.showProject;
        showDateCheckbox.checked = preferences.showDate;
        excludeEmptyDatesCheckbox.checked = preferences.excludeEmptyDates;
        includeNotesCheckbox.checked = preferences.includeNotes;
        minTimeSpentInput.value = preferences.minTimeSpent;
        showTimeSpentCheckbox.checked = preferences.showTimeSpent;
        showTotalTimeCheckbox.checked = preferences.showTotalTime;
        
        // Update visibility based on groupBy
        updateGroupByVisibility();
      }

      // Update visibility of checkboxes based on groupBy selection
      function updateGroupByVisibility() {
        if (groupBySelect.value === 'date') {
          showProjectCheckboxContainer.style.display = 'flex';
          showDateCheckboxContainer.style.display = 'none';
          excludeEmptyDatesCheckbox.parentElement.querySelector('label').textContent = 'Exclude dates with no tasks';
        } else {
          showProjectCheckboxContainer.style.display = 'none';
          showDateCheckboxContainer.style.display = 'flex';
          excludeEmptyDatesCheckbox.parentElement.querySelector('label').textContent = 'Exclude projects with no tasks';
        }
      }

      // Show preferences modal
      function showPreferencesModal() {
        preferencesModal.classList.add('show');
      }

      // Hide preferences modal
      function hidePreferencesModal() {
        preferencesModal.classList.remove('show');
      }

      // Save preferences
      async function savePreferences() {
        try {
          preferences.groupBy = groupBySelect.value;
          preferences.showProject = showProjectCheckbox.checked;
          preferences.showDate = showDateCheckbox.checked;
          preferences.excludeEmptyDates = excludeEmptyDatesCheckbox.checked;
          preferences.includeNotes = includeNotesCheckbox.checked;
          preferences.minTimeSpent = parseInt(minTimeSpentInput.value);
          preferences.showTimeSpent = showTimeSpentCheckbox.checked;
          preferences.showTotalTime = showTotalTimeCheckbox.checked;

          await persistReports();
          hidePreferencesModal();

          PluginAPI.showSnack({
            msg: 'Preferences saved successfully!',
            type: 'SUCCESS',
            ico: 'settings',
          });
        } catch (error) {
          console.error('Error saving preferences:', error);
          PluginAPI.showSnack({
            msg: 'Failed to save preferences',
            type: 'ERROR',
          });
        }
      }

      // Cancel preferences (restore previous values)
      function cancelPreferences() {
        applyPreferences();
        hidePreferencesModal();
      }

      // Render saved reports list
      function renderSavedReports() {
        if (savedReports.length === 0) {
          savedReportsList.innerHTML = '<div class="empty-state">No saved reports yet. Generate and save a report to get started.</div>';
          deleteSelectedBtn.style.display = 'none';
          return;
        }

        savedReportsList.innerHTML = savedReports.map(report => {
          const reportTypeIcon = report.type === 'current-tasks' ? 'üìã' : 'üìä';
          const reportTypeLabel = report.type === 'current-tasks' ? 'Current Tasks' : 'Task Completion';
          const dateInfo = report.startDate && report.endDate
            ? `${formatDateDisplay(report.startDate)} - ${formatDateDisplay(report.endDate)} ¬∑ `
            : '';

          return `
            <div class="saved-report-item" data-id="${report.id}">
              <input type="checkbox" class="saved-report-checkbox" data-id="${report.id}" />
              <div class="saved-report-info" onclick="viewReport('${report.id}')">
                <div class="saved-report-name">${reportTypeIcon} ${report.name}</div>
                <div class="saved-report-meta">
                  ${dateInfo}${reportTypeLabel} ¬∑ Saved ${new Date(report.savedAt).toLocaleDateString()}
                </div>
              </div>
              <div class="saved-report-actions">
                <button class="icon-btn delete-btn" onclick="deleteReport('${report.id}')" title="Delete">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');

        // Update delete selected button visibility
        updateDeleteSelectedButton();
      }

      // View saved report
      function viewReport(reportId) {
        const report = savedReports.find(r => r.id === reportId);
        if (report) {
          currentReport = report;
          isEditingExisting = true;
          showReportModal(report.content);
        }
      }

      // Delete single report
      async function deleteReport(reportId) {
        if (!confirm('Are you sure you want to delete this report?')) {
          return;
        }

        try {
          savedReports = savedReports.filter(r => r.id !== reportId);
          await persistReports();
          renderSavedReports();

          PluginAPI.showSnack({
            msg: 'Report deleted successfully',
            type: 'SUCCESS',
          });
        } catch (error) {
          console.error('Error deleting report:', error);
          PluginAPI.showSnack({
            msg: 'Failed to delete report',
            type: 'ERROR',
          });
        }
      }

      // Delete selected reports
      async function deleteSelectedReports() {
        const checkboxes = document.querySelectorAll('.saved-report-checkbox:checked');
        if (checkboxes.length === 0) {
          return;
        }

        if (!confirm(`Are you sure you want to delete ${checkboxes.length} report${checkboxes.length !== 1 ? 's' : ''}?`)) {
          return;
        }

        try {
          const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.id);
          savedReports = savedReports.filter(r => !selectedIds.includes(r.id));
          await persistReports();
          renderSavedReports();

          PluginAPI.showSnack({
            msg: `${checkboxes.length} report${checkboxes.length !== 1 ? 's' : ''} deleted successfully`,
            type: 'SUCCESS',
          });
        } catch (error) {
          console.error('Error deleting reports:', error);
          PluginAPI.showSnack({
            msg: 'Failed to delete reports',
            type: 'ERROR',
          });
        }
      }

      // Combine selected reports
      async function combineSelectedReports() {
        const checkboxes = document.querySelectorAll('.saved-report-checkbox:checked');
        if (checkboxes.length === 0) {
          return;
        }

        if (checkboxes.length < 2) {
          PluginAPI.showSnack({
            msg: 'Please select at least 2 reports to combine',
            type: 'ERROR',
          });
          return;
        }

        try {
          const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.id);
          const selectedReports = savedReports.filter(r => selectedIds.includes(r.id));
          
          // Sort reports by their saved date (oldest first)
          selectedReports.sort((a, b) => new Date(a.savedAt) - new Date(b.savedAt));
          
          // Combine the reports with separators
          let combinedContent = `# Combined Report\n\n`;
          combinedContent += `**Combined from ${selectedReports.length} reports**  \n`;
          combinedContent += `**Generated:** ${new Date().toLocaleString()}  \n\n`;
          combinedContent += `---\n\n`;
          
          selectedReports.forEach((report, index) => {
            if (index > 0) {
              combinedContent += `\n---\n\n`;
            }
            combinedContent += `## Report ${index + 1}: ${report.name}\n\n`;
            // Remove the first line (header) from each report if it starts with "# "
            const reportLines = report.content.split('\n');
            let contentStartIndex = 0;
            if (reportLines[0].startsWith('# ')) {
              contentStartIndex = 1;
            }
            combinedContent += reportLines.slice(contentStartIndex).join('\n');
          });

          // Create a temporary report object for the combined report
          currentReport = {
            content: combinedContent,
            startDate: selectedReports[0].startDate,
            endDate: selectedReports[selectedReports.length - 1].endDate,
            totalTasks: selectedReports.reduce((sum, r) => sum + (r.totalTasks || 0), 0),
            generatedAt: new Date().toISOString(),
            isCombined: true
          };

          isEditingExisting = false;
          showReportModal(combinedContent, `Combined from ${selectedReports.length} reports`);

          PluginAPI.showSnack({
            msg: `Combined ${selectedReports.length} reports successfully`,
            type: 'SUCCESS',
          });
        } catch (error) {
          console.error('Error combining reports:', error);
          PluginAPI.showSnack({
            msg: 'Failed to combine reports',
            type: 'ERROR',
          });
        }
      }

      // Update delete selected button visibility
      function updateDeleteSelectedButton() {
        // Use event delegation for checkboxes
        savedReportsList.addEventListener('change', (e) => {
          if (e.target.classList.contains('saved-report-checkbox')) {
            const checkedCount = document.querySelectorAll('.saved-report-checkbox:checked').length;
            deleteSelectedBtn.style.display = checkedCount > 0 ? 'block' : 'none';
            combineSelectedBtn.style.display = checkedCount > 0 ? 'block' : 'none';
          }
        });
      }

      // Copy to clipboard (legacy function for backward compatibility)
      async function copyToClipboard() {
        await copyFromModal();
      }

      // Event listeners
      generateBtn.addEventListener('click', generateReport);
      closeModalBtn.addEventListener('click', hideReportModal);
      modalCopyBtn.addEventListener('click', copyFromModal);
      modalSaveBtn.addEventListener('click', saveReport);
      deleteSelectedBtn.addEventListener('click', deleteSelectedReports);
      combineSelectedBtn.addEventListener('click', combineSelectedReports);

      // Preferences modal event listeners
      settingsBtn.addEventListener('click', showPreferencesModal);
      closePreferencesBtn.addEventListener('click', hidePreferencesModal);
      cancelPreferencesBtn.addEventListener('click', cancelPreferences);
      savePreferencesBtn.addEventListener('click', savePreferences);

      // Current tasks event listeners
      generateCurrentTasksBtn.addEventListener('click', showCurrentTasksModal);
      closeCurrentTasksModalBtn.addEventListener('click', hideCurrentTasksModal);
      generateCurrentTasksReportBtn.addEventListener('click', generateCurrentTasksReportAsync);
      currentTasksCopyBtn.addEventListener('click', copyCurrentTasksReport);
      currentTasksSaveBtn.addEventListener('click', saveCurrentTasksReport);
      filterByTagsCheckbox.addEventListener('change', toggleTagsFilter);

      // Handle groupBy change to show/hide appropriate checkboxes
      groupBySelect.addEventListener('change', updateGroupByVisibility);

      // Close modals on overlay click
      reportModal.addEventListener('click', (e) => {
        if (e.target === reportModal) {
          hideReportModal();
        }
      });

      preferencesModal.addEventListener('click', (e) => {
        if (e.target === preferencesModal) {
          hidePreferencesModal();
        }
      });

      currentTasksModal.addEventListener('click', (e) => {
        if (e.target === currentTasksModal) {
          hideCurrentTasksModal();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (reportModal.classList.contains('show')) {
            hideReportModal();
          } else if (preferencesModal.classList.contains('show')) {
            hidePreferencesModal();
          } else if (currentTasksModal.classList.contains('show')) {
            hideCurrentTasksModal();
          }
        }
      });

      // Allow Enter key to generate report
      startDateInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') generateReport();
      });

      endDateInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') generateReport();
      });

      // Make functions globally accessible for onclick handlers
      window.viewReport = viewReport;
      window.deleteReport = deleteReport;

      document.addEventListener("DOMContentLoaded", function() {
        // Load saved reports on initialization
        loadReports();
      });
      
    </script>
  </body>
</html>
